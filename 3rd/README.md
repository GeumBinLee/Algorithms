### 문자열 내의 p와 y의 개수
---
1. 첫 번째 방법 (이걸로 결정)
- 모든 문자를 소문자(or 대문자)로 바꾼다.
- p와 y의 개수가 다르면 False를 반환하고(if)
- 나머지 경우는(else) 모두 True를 반환한다.

2. 두 번째 방법
- p와 P 모두 p_count += 1
- y와 Y 모두 y_count += 1
- p_count와 y_count가 다를 때 False 반환
- 나머지 경우는 모두 True 반환.


### 핸드폰 번호 가리기
---
1. 끝에 네자리는 고정이니까 슬라이싱으로 잘라오기
2. 핸드폰 번호 자릿수-4개만큼 * 붙이기
3. 어차피 문자열이니까 +로 붙이기

### 제일 작은 수 제거하기
---
1. 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다. 라는 건 어차피 중복되지 않는다는 거니까 sort에 reverse=True 해서 내림차순 정렬
2. -1 인덱스의 원소 삭제
3. 배열의 개수가 0이면 -1 append하고 나서 리턴, 아닐 경우 배열 그대로 리턴
으로 했는데 안 됨. 배열 내에서 순서가 바뀌면 안 되나보지?

1. 인덱스 i, j에 대해 i ≠ j이면 arr[i] ≠ arr[j] 입니다. 라는 건 어차피 중복되지 않는다는 거니까 심플하게 min(arr)로 최솟값 찾고
2. index()로 걔가 몇 번째 앤지 찾아서
3. pop으로 빼오기
4. 그 후 배열 개수가 0이면 -1 append하고 arr 반환, 0이 아니면 배열 그대로 리턴

### 콜라츠 추측
---
1. 주어진 수가 1이면 0, 아닐 때는 아래 과정 시작
2. 언제 1이 될지 모르니까 반복문은 while로 돈다.
3. 멈추는 시점을 if문을 통해 1이 되는 순간으로 잡는다.
4. 반복할 때마다 미리 설정해 둔 count += 1
5. if문에 1이 되는 순간 return count
6. count가 500이 되는 순간 break으로 반복문 빠져나가고 return -1

### 수박수박수박수박수박수?
---
1. 주어진 n만큼 for문을 돈다.
2. for문을 도는 횟수 숫자가 홀수면 + "수"
3. 짝수면 + "박"

### 가운데 글자 가져오기
---
1. 인덱싱으로 꺼내쓰고 싶으니까 list(s)
2. len(s)가 홀수면 len(s)//2번째 인덱스 값 반환
3. len(s)가 짝수면 len(s)//2번째 인덱스랑 s//2-1 인덱스

### 올바른 괄호 - 스택/큐 (효율성 검사 실패)
---
1. while로 s.count("()")가 0이 될 때까지 while 돌기
2. 반복문 돌 때마다 () 삭제 -> replace("()", "")
3. len(s)가 0이면 True, 아니면 False

1. for문으로 바꿔보자

2. 악 ()이 더 이상 존재하지 않으면 for문을 빠져나오자

### H-index - 정렬 (실패)
---
1-1. 본인보다 크거나 같은 수의 개수와 본인보다 작거나 같은 수의 개수가 같은 수를 하나의 리스트에 모은다.
1-2. max()를 통해 그 중 최댓값을 찾아낸다.
첫 번째 방법 실패! 그냥 출처에 걸려있는 위키백과 읽고 문제 다시 이해함.

2-1. 인용 횟수를 담은 배열 citations를 내림차순으로 정렬
2-2. 인덱스 번호가 그 인덱스에 해당하는 값보다 크거나 같아지는 순간을 찾는다.
2-3. 그 순간의 인덱스 번호보다 인용 횟수가 큰 논문의 개수를 구한다.


### 포켓몬 - 해시 
---
1. 총 포켓몬 수 = len(nums)
2. 가져갈 포켓몬 수 = len(nums)//2
3. 걍 쉽게 생각하면 무조건 한 종류에 한마리씩만 데려가고, 가져갈 수 있는 최댓값을 구하면 됨.
4. 가져갈 포켓몬 수가 포켓몬 종류 수보다 크거나 작으면 어차피 종류별로 다 가져갈 수 있는 거니까 포켓몬 종류 수 반환
5. 가져갈 포켓몬 수가 포켓몬 종류 수보다 작으면 가져갈 수만큼밖에 못 가져가니까 가져갈 포켓몬 수 반환

### 다트 게임 2018 KAKAO BLIND RECRUITMENT
---
1. 점수 / S, D, T / *, # 구분하기
2. S, D, T에 따른 점수
3. *, #에 따른 점수